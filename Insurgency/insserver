#!/bin/bash
# Insurgency
# Server Management Script
# Author: Daniel Gibbs
# Website: http://gameservermanagers.com

version="180116"

#### Variables ####

# The name of this script file, used to show the LGSM link properly
selfname=$(basename $(readlink -f "${BASH_SOURCE[0]}"))

# Directories
rootdir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
scriptcfgdir="${rootdir}/cfg/servers"

# Debugging, if debugflag exists send output to $debuglog
debugflag="${rootdir}/.dev-debug"
debuglog="${rootdir}/dev-debug.log"
if [ -f "${debugflag}" ]; then
	exec 5>${debuglog}
	BASH_XTRACEFD="5"
	set -x
fi

# Settings to get before config parsing begins
engine="source"
# Game name for file paths
game="insurgency"
# Name for subdirectory in GitHub repo
gamename="Insurgency"
# Name of this service (for symlinked instances)
servicename="$(basename $0)"

# File fetching settings
# Github Branch Select
# Allows for the use of different function files
# from a different repo and/or branch.
githubuser="jaredballou"
githubrepo="linuxgsm"
githubbranch="master"

#ipaddr=$(ip addr | grep 'state UP' -A2 | tail -n1 | awk '{print $2}' | cut -f1  -d'/')

# Config files
cfg_file_default="${scriptcfgdir}/_default.cfg"
cfg_file_common="${scriptcfgdir}/_common.cfg"
cfg_file_instance="${scriptcfgdir}/${servicename}.cfg"

# Config file headers
cfg_header_all="# Your settings for all servers go in _common.cfg\n# Server-specific settings go into \$SERVER.cfg"
cfg_header_default="# Default config - Changes will be overwritten by updates.\n${cfg_header_all}"
cfg_header_common="# Common config - Will not be overwritten by script.\n${cfg_header_all}"
cfg_header_instance="# Instance Config for ${servicename} - Will not be overwritten by script.\n${cfg_header_all}"

# If default config does not exist, create it. This should come from Git, and will be overwritten by updates.
# Rather than try to wget it from Github or other fancy ways to get it, the simplest way to ensure it works is to simply create it here.
fn_update_config()
{
	key=$1
	val=$2
	cfg_file=${3:-$cfg_file_default}
	comment=${4:-""}
	# Put " # " at beginning of comment if not empty
	if [ "${comment}" != "" ]
	then
		comment=" # ${comment}"
	fi

	# Line to be put in
	data="${key}=\"${val}\"${comment}"

	# Get current key/value pair from file
	exists=$(grep "^${key}=" $cfg_file)

	# Check if key exists in config
	if [ "${exists}" != "" ]; then
		# If the line isn't the same as the parsed data line, replace it
		if [ "${exists}" != "${data}" ]; then
			echo "Updating ${data} in ${cfg_file}"
			sed -e "s/^${key}=.*\$/${data}/g" -i $cfg_file
		fi
	else
		# If value does not exist, append to file
		echo "Adding ${data} to ${cfg_file}"
		echo -ne "${data}\n" >> $cfg_file
	fi
}
fn_create_config(){
	cfg_type=${1:-default}
	cfg_file="cfg_file_${cfg_type}"
	cfg_header="cfg_header_${cfg_type}"
	
	cfg_dir=$(dirname ${!cfg_file})
	#If config directory does not exist, create it
	if [ ! -e $cfg_dir ]; then mkdir -p $cfg_dir; fi

	# Create file header if needed
	if [ ! -e ${!cfg_file} ]; then
		echo "Creating ${cfg_type} config at ${!cfg_file}"
		echo -ne "${!cfg_header}\n\n" > ${!cfg_file}
	fi

	# Default config values
	if [ "${cfg_type}" == "default" ]; then
		fn_update_config "appid" "237410"
		fn_update_config "beta" "" "${!cfg_file}" "To enable beta, use \"-beta beta\""
		fn_update_config "clientport" "27005"
		fn_update_config "defaultmap" "ministry"
		fn_update_config "defaultmode" "checkpoint"
		fn_update_config "email" "email@example.com"
		fn_update_config "emailnotification" "off" "$cfg_file_default" "(on|off)"
		fn_update_config "ip" "0.0.0.0"
		fn_update_config "lgsm_version" $version
		fn_update_config "logdays" "7"
		fn_update_config "mapcyclefile" "mapcycle.txt"
		fn_update_config "maxplayers" "64"
		fn_update_config "playlist" "custom"
		fn_update_config "port" "27015"
		fn_update_config "sourcetvport" "27020"
		fn_update_config "srcds_parms" "" "$cfg_file_default" "Put the parameters that start with \"-\" first, then \"+\" parameters after"
		fn_update_config "steampass" ""
		fn_update_config "steamuser" "anonymous"
		fn_update_config "updateonstart" "off"
	fi
}

# If defaults are missing, or from an older version, overwrite the file
# TODO: Perhaps pull this from Git instead?
#cfgver=$(grep lgsm_version ${cfg_file_default} 2>/dev/null | cut -d'=' -f2 | sed -e 's/["]//g')
#if [ "${cfgver}" != "${version}" ]; then 

# New method is to always run this function, it will overwrite defaults with whatever the new script values are
fn_create_config default

# Load defaults
source $cfg_file_default

# Load sitewide common settings (so that Git updates can safely overwrite default.cfg)
if [ ! -f $cfg_file_common ]; then fn_create_config common; else source $cfg_file_common; fi

# Load instance specific settings
if [ ! -f $cfg_file_instance ]; then fn_create_config instance; else source $cfg_file_instance; fi

# Set the paramaters to send to srcds
# https://developer.valvesoftware.com/wiki/Command_Line_Options#Source_Dedicated_Server


fn_parms(){
#TODO: Put in some conditional logic to handle generating the parm string so we can make this a little less game specific
parms="${parms} -game ${game}"
parms="${parms} -strictportbind"
parms="${parms} -ip ${ip}"
parms="${parms} -port ${port}"
parms="${parms} -maxplayers ${maxplayers}"
parms="${parms} ${srcds_parms}"
parms="${parms} +clientport ${clientport}"
parms="${parms} +tv_port ${sourcetvport}"
parms="${parms} +sv_playlist ${playlist}"
parms="${parms} +mapcyclefile ${mapcyclefile}"
parms="${parms} +servercfgfile ${servercfg}"
parms="${parms} +map ${defaultmap} ${defaultmode}"
}

#### Advanced Variables ####
# Directories
lockselfname=".${servicename}.lock"
filesdir="${rootdir}/serverfiles"
systemdir="${filesdir}/insurgency"
executabledir="${filesdir}"
executable="./srcds_linux"
servercfg="${servicename}.cfg"
servercfgdir="${systemdir}/cfg"
servercfgfullpath="${servercfgdir}/${servercfg}"
servercfgdefault="${servercfgdir}/lgsm-default.cfg"
backupdir="${rootdir}/backups"

#In the event that you have library issues after an update, this may resolve it.
#export LD_LIBRARY_PATH="${filesdir}:${filesdir}/bin:${LD_LIBRARY_PATH}"

# Logging
gamelogdir="${systemdir}/logs"
scriptlogdir="${rootdir}/log/script"
consolelogdir="${rootdir}/log/console"

scriptlog="${scriptlogdir}/${servicename}-script.log"
consolelog="${consolelogdir}/${servicename}-console.log"
emaillog="${scriptlogdir}/${servicename}-email.log"

scriptlogdate="${scriptlogdir}/${servicename}-script-$(date '+%d-%m-%Y-%H-%M-%S').log"
consolelogdate="${consolelogdir}/${servicename}-console-$(date '+%d-%m-%Y-%H-%M-%S').log"

##### Script #####
# Do not edit

# fn_colortext color msg
# Display a message with a color code
# Paremeters:
# color: Numeric color code
# msg: Message. This includes all further paremeters, so there is no need to quote a message with spaces in it.
fn_colortext(){
	color=$1
	msg=${@:2}
	echo -e "\e[0;${color}m${msg}\e[0m"
}

# Set fetchcmd to the full path of whatever command we can to fetch files
for fetchcmd in curl wget
do
	paths="$(command -v ${fetchcmd} 2>/dev/null) $(which ${fetchcmd} >/dev/null 2>&1) /usr/bin/${fetchcmd} /bin/${fetchcmd} /usr/sbin/${fetchcmd} /sbin/${fetchcmd} $(echo $PATH | sed "s/\([:]\|\$\)/\/${fetchcmd} /g")"
	for tp in $paths
	do
		if [ -x $tp ]; then
			fetchcmd=$tp
			break 2
		fi
	done
done
# If we have no executable fetchcmd, fail script execution
if [ ! -x "${fetchcmd}" ]; then
	fn_colortext 31 FAIL
	echo "Cannot find curl or wget!"
	exit 1
fi

# fn_getgithubfile filename [exec] [url]
# Download file from Github
# Parameters:
# filename: The path of the file in reference to the repository root
# exec: Optional, set to 1 to make file executable
# url: Optional, set to full path under repository root if different than filename
fn_getgithubfile(){
	filename=$1
	exec=$2
	fileurl=${3:-$filename}
	filepath="${rootdir}/${filename}"
	filedir=$(dirname "${filepath}")
	# If the function file is missing, then download
	if [ ! -f "${filepath}" ]; then
		if [ ! -d "${filedir}" ]; then
			mkdir "${filedir}"
		fi
		githuburl="https://raw.githubusercontent.com/${githubuser}/${githubrepo}/${githubbranch}/${fileurl}"
		echo -e "    fetching ${filename} (${githuburl})\c"
		if [ "$(basename ${fetchcmd})" == "curl" ]; then
			cmd="$fetchcmd -s --fail -o"
		elif [ "$(basename ${fetchcmd})" == "wget" ]; then
			cmd="$fetchcmd -O"
		fi
		fetch=$($cmd "${filepath}" "${githuburl}" 2>&1)
		if [ "${exec}" ]; then
			chmod +x "${filepath}"
		fi
	fi
	if [ "${exec}" ]; then
		source "${filepath}"
	fi
}

# fn_runfunction
fn_runfunction(){
	fn_getgithubfile "functions/${functionfile}" 1
}

# core_functions.sh
core_functions.sh(){
	# Functions are defined in core_functions.sh.
	functionfile="${FUNCNAME}"
	fn_runfunction
}

core_functions.sh

getopt=$1
core_getopt.sh
